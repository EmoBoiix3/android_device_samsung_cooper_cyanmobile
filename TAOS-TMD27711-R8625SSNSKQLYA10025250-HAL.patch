Revision: 52684524005d3c28e8a08c964726a9d49b07be4f, Thu Jun 7 17:25:59 2012 +0800
diff --git a/libsku7sensors/Android.mk b/libsku7sensors/Android.mk
index b797705..5b419b8 100644
--- a/libsku7sensors/Android.mk
+++ b/libsku7sensors/Android.mk
@@ -20,7 +20,7 @@ LOCAL_PATH := $(call my-dir)
 # hw/<SENSORS_HARDWARE_MODULE_ID>.<ro.product.board>.so
 include $(CLEAR_VARS)
 
-LOCAL_MODULE := sensors.msm7627a_sku7
+LOCAL_MODULE := sensors.msm8x25_evb
 
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
 
@@ -29,12 +29,13 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_CFLAGS := -DLOG_TAG=\"Sensors\" \
 				-Wall
 
+LOCAL_CFLAGS += -DTMD27711_SENSOR
+
 LOCAL_SRC_FILES := \
 			SensorBase.cpp \
 			InputEventReader.cpp \
 			AkmSensor.cpp \
-			ProximitySensor.cpp \
-			LightSensor.cpp \
+			TmdSensor.cpp \
 			AccSensor.cpp \
 			sensors.cpp
 
diff --git a/libsku7sensors/TmdSensor.cpp b/libsku7sensors/TmdSensor.cpp
new file mode 100644
index 0000000..16624d6
--- /dev/null
+++ b/libsku7sensors/TmdSensor.cpp
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include "TmdSensor.h"
+#include "taos_common.h"
+#include <cutils/log.h>
+
+/*****************************************************************************/
+
+TmdSensor::TmdSensor(): SensorBase("/dev/tmd27711", "tmd27711"),
+	mAlsEnabled(0),
+	mProxEnabled(0),
+	mInputReader(32),
+	mHasPendingEvent(false)
+{
+	open_device();
+	if (data_fd >= 0) {
+		ioctl(dev_fd, TAOS_IOCTL_SENSOR_ON, 0);
+		ioctl(dev_fd, TAOS_IOCTL_PROX_CALIBRATE, 0);
+		ioctl(dev_fd, TAOS_IOCTL_ALS_CALIBRATE, 0);
+	}
+}
+
+TmdSensor::~TmdSensor(){
+	ioctl(dev_fd, TAOS_IOCTL_SENSOR_OFF, 0);
+}
+
+int TmdSensor::setInitialState() {
+	struct input_absinfo absinfo;
+    if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_PROXIMITY), &absinfo)) {
+        // make sure to report an event immediately
+        mHasPendingEvent = true;
+        mPendingEvent.distance = indexToValue(absinfo.value);
+    }
+	return 0;
+}
+
+int TmdSensor::setEnable(int32_t handle, int enabled) {
+	int flags = enabled ? 1 : 0;
+	int err = 0;
+
+	if ((handle == ID_L) && (flags != mAlsEnabled)) {
+		mAlsEnabled = flags;
+		if (flags == 1) {
+			ioctl(dev_fd,TAOS_IOCTL_ALS_ON,0);
+		} else {
+			ioctl(dev_fd,TAOS_IOCTL_ALS_OFF,0);
+		}
+	}
+	if ((handle == ID_P) && (flags != mProxEnabled)) {
+		mProxEnabled = flags;
+		if (flags == 1) {
+			ioctl(dev_fd,TAOS_IOCTL_PROX_ON,0);
+		} else {
+			ioctl(dev_fd,TAOS_IOCTL_PROX_OFF,0);
+		}
+	}
+	return err;
+}
+
+bool TmdSensor::hasPendingEvents() const {
+	return mHasPendingEvent;
+}
+
+int TmdSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event))
+		{
+		int type = event->type;
+		if (type == EV_ABS) {
+			processEvent(event->code, event->value);
+		} else if (type == EV_SYN) {
+			int64_t time = timevalToNano(event->time);
+			mPendingEvent.timestamp = time;
+			*data++ = mPendingEvent;
+			count--;
+			numEventReceived++;
+		} else {
+			LOGE("tmd27711 Sensor: unknown event (type=%d, code=%d)",
+				type, event->code);
+			}
+			mInputReader.next();
+		}
+	return numEventReceived;
+}
+
+void TmdSensor::processEvent(int code, int value)
+{
+	switch (code) {
+		case ABS_DISTANCE:
+			mPendingEvent.version = sizeof(sensors_event_t);
+			mPendingEvent.sensor = ID_P;
+			mPendingEvent.type = SENSOR_TYPE_PROXIMITY;
+			memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+			mPendingEvent.distance = (value > 0)? 5:0;
+			break;
+		case ABS_MISC:
+			mPendingEvent.version = sizeof(sensors_event_t);
+			mPendingEvent.sensor = ID_L;
+			mPendingEvent.type = SENSOR_TYPE_LIGHT;
+			memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+			mPendingEvent.light = value;
+			break;
+		default:
+			break;
+		}
+
+}
+int TmdSensor::getFd() const
+{
+	return data_fd;
+}
+
+int TmdSensor::getEnable(int32_t handle) {
+	int en = 0;
+	if(handle == ID_L)
+		en = mAlsEnabled;
+	if(handle == ID_P)
+		en = mProxEnabled;
+	return en;
+}
+int TmdSensor::setDelay(int32_t handle, int64_t ns) {
+	return 0;
+};
+
+float TmdSensor::indexToValue(size_t index) const
+{
+    return index * PROXIMITY_THRESHOLD_GP2A;
+}
diff --git a/libsku7sensors/TmdSensor.h b/libsku7sensors/TmdSensor.h
new file mode 100644
index 0000000..c0bfeeb
--- /dev/null
+++ b/libsku7sensors/TmdSensor.h
@@ -0,0 +1,36 @@
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+class TmdSensor : public SensorBase {
+public:
+	TmdSensor();
+	virtual ~TmdSensor();
+
+	virtual int setEnable(int32_t handle, int enabled);
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents(void) const;
+	void processEvent(int code, int value);
+	int setInitialState(void);
+	int getFd() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int getEnable(int32_t handle);		//rockie
+	float indexToValue(size_t index) const;
+
+	int mAlsEnabled;
+	int mProxEnabled;
+	bool mHasPendingEvent;
+private:
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+};
+/*****************************************************************************/
diff --git a/libsku7sensors/sensors.cpp b/libsku7sensors/sensors.cpp
index f137261..48aec17 100644
--- a/libsku7sensors/sensors.cpp
+++ b/libsku7sensors/sensors.cpp
@@ -32,8 +32,12 @@
 #include <utils/Log.h>
 
 #include "sensors.h"
+#ifdef TMD27711_SENSOR
+#include "TmdSensor.h"
+#else
 #include "LightSensor.h"
 #include "ProximitySensor.h"
+#endif
 #include "AccSensor.h"
 #include "AkmSensor.h"
 
@@ -74,6 +78,16 @@ static const struct sensor_t sSensorList[] = {
           1, SENSORS_ORIENTATION_HANDLE,
           SENSOR_TYPE_ORIENTATION, 360.0f,
 		  CONVERT_O, 1.05f, 10000, { } },
+#ifdef TMD27711_SENSOR
+	{ "TMD27711 light sensor",
+	  "TAOS",
+	  1, SENSORS_LIGHT_HANDLE,
+	  SENSOR_TYPE_LIGHT, 10000.0f, 1.0f, 0.5f, 0,{ } },
+	{ "TMD27711 proximity sensor",
+	  "TAOS",
+	  1, SENSORS_PROXIMITY_HANDLE,
+	  SENSOR_TYPE_PROXIMITY, 5.0f, 1.0f, 0.5f, 0,{ } },
+#else
         { "LTR502 Light sensor",
           "Liteon",
           1, SENSORS_LIGHT_HANDLE,
@@ -82,6 +96,7 @@ static const struct sensor_t sSensorList[] = {
           "Liteon",
           1, SENSORS_PROXIMITY_HANDLE,
           SENSOR_TYPE_PROXIMITY, 5.0f, 5.0f, 0.75f, 0, { } },
+#endif
 };
 
 
@@ -126,8 +141,12 @@ private:
     enum {
         acc          = 0,
         akm          = 1,
+#ifdef TMD27711_SENSOR
+	tmd	     = 2,
+#else
         light        = 2,
         proximity    = 3,
+#endif
         numSensorDrivers,
         numFds,
     };
@@ -161,6 +180,12 @@ sensors_poll_context_t::sensors_poll_context_t()
     mPollFds[akm].events = POLLIN;
     mPollFds[akm].revents = 0;
 
+#ifdef TMD27711_SENSOR
+    mSensors[tmd] = new TmdSensor();
+    mPollFds[tmd].fd = mSensors[tmd]->getFd();
+    mPollFds[tmd].events = POLLIN;
+    mPollFds[tmd].revents = 0;
+#else
     mSensors[light] = new LightSensor();
     mPollFds[light].fd = mSensors[light]->getFd();
     mPollFds[light].events = POLLIN;
@@ -170,6 +195,7 @@ sensors_poll_context_t::sensors_poll_context_t()
     mPollFds[proximity].fd = mSensors[proximity]->getFd();
     mPollFds[proximity].events = POLLIN;
     mPollFds[proximity].revents = 0;
+#endif
 
     int wakeFds[2];
     int result = pipe(wakeFds);
@@ -198,10 +224,16 @@ int sensors_poll_context_t::handleToDriver(int handle) {
 		case ID_M:
 		case ID_O:
 			return akm;
+#ifdef TMD27711_SENSOR
+		case ID_P:
+		case ID_L:
+			return tmd;
+#else
 		case ID_P:
 			return proximity;
 		case ID_L:
 			return light;
+#endif
 	}
 	return -EINVAL;
 }
diff --git a/libsku7sensors/taos_common.h b/libsku7sensors/taos_common.h
new file mode 100644
index 0000000..da92a76
--- /dev/null
+++ b/libsku7sensors/taos_common.h
@@ -0,0 +1,59 @@
+/*******************************************************************************
+*                                                                              *
+*       File Name:      taos_common.h                                          *
+*       Description:    Common file for ioctl and configuration definitions.   *
+*       		Used by kernel driver and driver access applications.  *
+*       		Please include this file, and <sys/ioctl.h> in your    *
+*                       driver access application program source.	       *
+*       Author:         John Koshi                                             *
+*       History:        09/16/2009 - Initial creation                          *
+*       		02/07/2010 - Add proximity			       *
+*                                                                              *
+*******************************************************************************/
+// ioctl numbers
+#define TAOS_IOCTL_MAGIC        	0XCF
+#define TAOS_IOCTL_ALS_ON       	_IO(TAOS_IOCTL_MAGIC, 1)
+#define TAOS_IOCTL_ALS_OFF      	_IO(TAOS_IOCTL_MAGIC, 2)
+#define TAOS_IOCTL_ALS_DATA     	_IOR(TAOS_IOCTL_MAGIC, 3, short)
+#define TAOS_IOCTL_ALS_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 4)
+#define TAOS_IOCTL_CONFIG_GET   	_IOR(TAOS_IOCTL_MAGIC, 5, struct taos_cfg)
+#define TAOS_IOCTL_CONFIG_SET		_IOW(TAOS_IOCTL_MAGIC, 6, struct taos_cfg)
+#define TAOS_IOCTL_PROX_ON		_IO(TAOS_IOCTL_MAGIC, 7)
+#define TAOS_IOCTL_PROX_OFF		_IO(TAOS_IOCTL_MAGIC, 8)
+#define TAOS_IOCTL_PROX_DATA		_IOR(TAOS_IOCTL_MAGIC, 9, struct taos_prox_info)
+#define TAOS_IOCTL_PROX_EVENT       	_IO(TAOS_IOCTL_MAGIC, 10)
+#define TAOS_IOCTL_PROX_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 11)
+
+#define TAOS_IOCTL_SENSOR_ON		_IO(TAOS_IOCTL_MAGIC, 12)
+#define TAOS_IOCTL_SENSOR_OFF		_IO(TAOS_IOCTL_MAGIC, 13)
+#define TAOS_IOCTL_SENSOR_CONFIG	_IOW(TAOS_IOCTL_MAGIC, 14, struct taos_cfg)
+#define TAOS_IOCTL_SENSOR_CHECK		_IO(TAOS_IOCTL_MAGIC, 15)
+#define TAOS_IOCTL_SENSOR_test		_IO(TAOS_IOCTL_MAGIC, 16)
+
+// device configuration
+struct taos_cfg {
+	__u32   calibrate_target;
+	__u16   als_time;
+	__u16   scale_factor;
+	__u16   gain_trim;
+	__u8    filter_history;
+	__u8    filter_count;
+	__u8    gain;
+	__u16	prox_threshold_hi;
+	__u16   prox_threshold_lo;
+	__u16	als_threshold_hi;
+	__u16   als_threshold_lo;
+	__u8	prox_int_time;
+	__u8	prox_adc_time;
+	__u8	prox_wait_time;
+	__u8	prox_intr_filter;
+	__u8	prox_config;
+	__u8	prox_pulse_cnt;
+	__u8	prox_gain;
+};
+// proximity data
+struct taos_prox_info {
+	__u16   prox_clear;
+	__u16   prox_data;
+	int	prox_event;
+};
